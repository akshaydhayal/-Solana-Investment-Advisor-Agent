[{"language": "python", "name": "agent.py", "value": "import os\nimport json\nimport asyncio\nfrom datetime import datetime, timezone\nfrom uuid import uuid4\nfrom typing import Dict, List, Optional, Any\nimport httpx\nfrom uagents import Agent, Context, Protocol\nfrom uagents_core.storage import ExternalStorage\nfrom uagents_core.contrib.protocols.chat import (\n    chat_protocol_spec,\n    ChatMessage, ChatAcknowledgement,\n    TextContent, ResourceContent, Resource, MetadataContent,\n    StartSessionContent, EndSessionContent\n)\n\n# Configuration\nAGENTVERSE_URL = os.getenv(\"AGENTVERSE_URL\", \"https://agentverse.ai\")\nSTORAGE_URL = f\"{AGENTVERSE_URL}/v1/storage\"\nASI_ONE_API_KEY = os.getenv(\"ASI_ONE_API_KEY\")\nZERION_API_KEY = os.getenv(\"ZERION_API_KEY\", \"emtfZGV2X2IyNmFmZjFlMDY2ZjQ4NWNhMzdhZTI0MzVkMzI4NWY3Og==\")\n\n# Initialize agent\nagent = Agent()\nchat_proto = Protocol(spec=chat_protocol_spec)\n\n# Solana RPC endpoints\nSOLANA_RPC_URLS = [\n    \"https://api.mainnet-beta.solana.com\",\n    \"https://solana-api.projectserum.com\",\n    \"https://rpc.ankr.com/solana\"\n]\n\nclass SolanaWalletAnalyzer:\n    \"\"\"Analyzes Solana wallet data and provides investment recommendations\"\"\"\n    \n    def __init__(self):\n        self.asi_api_key = ASI_ONE_API_KEY\n        self.zerion_api_key = ZERION_API_KEY\n        self.rpc_urls = SOLANA_RPC_URLS\n    \n    async def get_wallet_balance(self, wallet_address: str) -> Dict[str, Any]:\n        \"\"\"Fetch wallet balance and token holdings from Solana blockchain\"\"\"\n        try:\n            async with httpx.AsyncClient(timeout=30) as client:\n                # Try multiple RPC endpoints for better reliability\n                for rpc_url in self.rpc_urls:\n                    try:\n                        # Get SOL balance\n                        sol_balance_response = await client.post(\n                            rpc_url,\n                            json={\n                                \"jsonrpc\": \"2.0\",\n                                \"id\": 1,\n                                \"method\": \"getBalance\",\n                                \"params\": [wallet_address]\n                            }\n                        )\n                        sol_balance_data = sol_balance_response.json()\n                        \n                        if \"error\" in sol_balance_data:\n                            continue\n                            \n                        # Get token accounts\n                        token_accounts_response = await client.post(\n                            rpc_url,\n                            json={\n                                \"jsonrpc\": \"2.0\",\n                                \"id\": 2,\n                                \"method\": \"getTokenAccountsByOwner\",\n                                \"params\": [\n                                    wallet_address,\n                                    {\"programId\": \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"},\n                                    {\"encoding\": \"jsonParsed\"}\n                                ]\n                            }\n                        )\n                        token_accounts_data = token_accounts_response.json()\n                        \n                        if \"error\" in token_accounts_data:\n                            continue\n                            \n                        return {\n                            \"sol_balance\": sol_balance_data.get(\"result\", {}).get(\"value\", 0) / 1e9,  # Convert lamports to SOL\n                            \"token_accounts\": token_accounts_data.get(\"result\", {}).get(\"value\", []),\n                            \"wallet_address\": wallet_address,\n                            \"rpc_used\": rpc_url\n                        }\n                    except Exception as e:\n                        print(f\"RPC {rpc_url} failed: {str(e)}\")\n                        continue\n                \n                # If all RPCs fail, try using Solscan API as fallback\n                try:\n                    solscan_response = await client.get(f\"https://api.solscan.io/account?address={wallet_address}\")\n                    if solscan_response.status_code == 200:\n                        solscan_data = solscan_response.json()\n                        return {\n                            \"sol_balance\": solscan_data.get(\"data\", {}).get(\"lamports\", 0) / 1e9,\n                            \"token_accounts\": [],  # Solscan doesn't provide token accounts in this endpoint\n                            \"wallet_address\": wallet_address,\n                            \"source\": \"solscan\"\n                        }\n                except Exception as e:\n                    print(f\"Solscan API failed: {str(e)}\")\n                \n                return {\"error\": \"All RPC endpoints and fallback APIs failed\"}\n                \n        except Exception as e:\n            return {\"error\": f\"Failed to fetch wallet data: {str(e)}\"}\n    \n    async def get_zerion_portfolio(self, wallet_address: str) -> Dict[str, Any]:\n        \"\"\"Fetch comprehensive portfolio data from Zerion API\"\"\"\n        try:\n            async with httpx.AsyncClient(timeout=30) as client:\n                url = f\"https://api.zerion.io/v1/wallets/{wallet_address}/portfolio?filter[positions]=only_simple&currency=usd\"\n                headers = {\n                    \"accept\": \"application/json\",\n                    \"authorization\": f\"Basic {self.zerion_api_key}\"\n                }\n                \n                response = await client.get(url, headers=headers)\n                \n                if response.status_code == 200:\n                    data = response.json()\n                    attributes = data.get(\"data\", {}).get(\"attributes\", {})\n                    \n                    return {\n                        \"total_value_usd\": attributes.get(\"total\", {}).get(\"positions\", 0),\n                        \"daily_change_usd\": attributes.get(\"changes\", {}).get(\"absolute_1d\", 0),\n                        \"daily_change_percent\": attributes.get(\"changes\", {}).get(\"percent_1d\", 0),\n                        \"distribution_by_type\": attributes.get(\"positions_distribution_by_type\", {}),\n                        \"distribution_by_chain\": attributes.get(\"positions_distribution_by_chain\", {}),\n                        \"source\": \"zerion\"\n                    }\n                else:\n                    print(f\"Zerion API error: {response.status_code}\")\n                    return {\"error\": f\"Zerion API error: {response.status_code}\"}\n                    \n        except Exception as e:\n            print(f\"Zerion API failed: {str(e)}\")\n            return {\"error\": f\"Failed to fetch Zerion data: {str(e)}\"}\n    \n    async def get_zerion_positions(self, wallet_address: str) -> List[Dict[str, Any]]:\n        \"\"\"Fetch detailed token positions with USD values from Zerion API\"\"\"\n        try:\n            async with httpx.AsyncClient(timeout=30) as client:\n                url = f\"https://api.zerion.io/v1/wallets/{wallet_address}/positions/?filter[positions]=only_simple&currency=usd&filter[chain_ids]=solana&filter[trash]=only_non_trash&sort=value\"\n                headers = {\n                    \"accept\": \"application/json\",\n                    \"authorization\": f\"Basic {self.zerion_api_key}\"\n                }\n                \n                response = await client.get(url, headers=headers)\n                \n                if response.status_code == 200:\n                    data = response.json()\n                    positions = []\n                    \n                    print(f\"Zerion API response status: {response.status_code}\")\n                    print(f\"Zerion API data keys: {data.keys() if isinstance(data, dict) else 'Not a dict'}\")\n                    \n                    for item in data.get(\"data\", []):\n                        attributes = item.get(\"attributes\", {})\n                        fungible_info = attributes.get(\"fungible_info\", {})\n                        quantity = attributes.get(\"quantity\", {})\n                        \n                        # Find Solana address from implementations\n                        solana_address = None\n                        for impl in fungible_info.get(\"implementations\", []):\n                            if impl.get(\"chain_id\") == \"solana\":\n                                solana_address = impl.get(\"address\")\n                                break\n                        \n                        position_data = {\n                            \"name\": fungible_info.get(\"name\", \"Unknown\"),\n                            \"symbol\": fungible_info.get(\"symbol\", \"UNK\"),\n                            \"address\": solana_address or attributes.get(\"id\", \"\").split(\"-\")[0],\n                            \"quantity\": quantity.get(\"float\", 0),\n                            \"value_usd\": attributes.get(\"value\"),\n                            \"price_usd\": attributes.get(\"price\", 0),\n                            \"changes_1d_usd\": attributes.get(\"changes\", {}).get(\"absolute_1d\", 0),\n                            \"changes_1d_percent\": attributes.get(\"changes\", {}).get(\"percent_1d\", 0),\n                            \"verified\": fungible_info.get(\"flags\", {}).get(\"verified\", False)\n                        }\n                        \n                        positions.append(position_data)\n                    \n                    print(f\"Processed {len(positions)} positions from Zerion\")\n                    return positions\n                else:\n                    print(f\"Zerion positions API error: {response.status_code}\")\n                    print(f\"Response: {response.text[:200]}\")\n                    return []\n                    \n        except Exception as e:\n            print(f\"Zerion positions API failed: {str(e)}\")\n            return []\n    \n    async def get_token_prices(self, token_mints: List[str]) -> Dict[str, float]:\n        \"\"\"Fetch current token prices\"\"\"\n        try:\n            async with httpx.AsyncClient(timeout=30) as client:\n                # Use Jupiter API for token prices\n                response = await client.get(\"https://price.jup.ag/v4/price\")\n                price_data = response.json()\n                \n                prices = {}\n                for token in price_data.get(\"data\", []):\n                    if token[\"id\"] in token_mints:\n                        prices[token[\"id\"]] = token[\"price\"]\n                \n                return prices\n        except Exception as e:\n            return {\"error\": f\"Failed to fetch token prices: {str(e)}\"}\n    \n    async def get_staking_opportunities(self) -> List[Dict[str, Any]]:\n        \"\"\"Get current staking opportunities and APY rates\"\"\"\n        try:\n            async with httpx.AsyncClient(timeout=30) as client:\n                # Try multiple staking data sources\n                staking_sources = [\n                    \"https://api.solanabeach.io/v1/validators\",\n                    \"https://api.solscan.io/chaininfo\"\n                ]\n                \n                for source_url in staking_sources:\n                    try:\n                        response = await client.get(source_url)\n                        if response.status_code == 200:\n                            data = response.json()\n                            \n                            if \"validators\" in data:\n                                # Solana Beach format\n                                validators = data.get(\"validators\", [])[:10]\n                                staking_ops = []\n                                for validator in validators:\n                                    staking_ops.append({\n                                        \"name\": validator.get(\"name\", \"Unknown\"),\n                                        \"apy\": validator.get(\"apy\", 7.5),  # Default APY if not available\n                                        \"commission\": validator.get(\"commission\", 5.0),\n                                        \"vote_account\": validator.get(\"vote_account\"),\n                                        \"description\": f\"Stake with {validator.get('name', 'Unknown')} for {validator.get('apy', 7.5):.2f}% APY\"\n                                    })\n                                return staking_ops\n                            else:\n                                # Fallback: return some default staking opportunities\n                                return [\n                                    {\n                                        \"name\": \"Solana Foundation\",\n                                        \"apy\": 7.2,\n                                        \"commission\": 0.0,\n                                        \"vote_account\": \"Vote1111111111111111111111111111111111111112\",\n                                        \"description\": \"Stake with Solana Foundation for 7.20% APY\"\n                                    },\n                                    {\n                                        \"name\": \"Marinade Finance\",\n                                        \"apy\": 6.8,\n                                        \"commission\": 2.0,\n                                        \"vote_account\": \"MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD\",\n                                        \"description\": \"Stake with Marinade Finance for 6.80% APY\"\n                                    },\n                                    {\n                                        \"name\": \"Jito Labs\",\n                                        \"apy\": 6.5,\n                                        \"commission\": 3.0,\n                                        \"vote_account\": \"Jito4APyf642JPZPx3hGc6WWJ8zPKtRbR4Xe2q7WnK\",\n                                        \"description\": \"Stake with Jito Labs for 6.50% APY\"\n                                    }\n                                ]\n                    except Exception as e:\n                        print(f\"Staking source {source_url} failed: {str(e)}\")\n                        continue\n                \n                # If all sources fail, return default staking opportunities\n                return [\n                    {\n                        \"name\": \"Solana Foundation\",\n                        \"apy\": 7.2,\n                        \"commission\": 0.0,\n                        \"vote_account\": \"Vote1111111111111111111111111111111111111112\",\n                        \"description\": \"Stake with Solana Foundation for 7.20% APY\"\n                    },\n                    {\n                        \"name\": \"Marinade Finance\",\n                        \"apy\": 6.8,\n                        \"commission\": 2.0,\n                        \"vote_account\": \"MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD\",\n                        \"description\": \"Stake with Marinade Finance for 6.80% APY\"\n                    }\n                ]\n        except Exception as e:\n            return [{\"error\": f\"Failed to fetch staking data: {str(e)}\"}]\n    \n    async def get_market_data(self) -> Dict[str, Any]:\n        \"\"\"Get current market data for better recommendations\"\"\"\n        try:\n            async with httpx.AsyncClient(timeout=30) as client:\n                # Get SOL price\n                sol_response = await client.get(\"https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd\")\n                sol_data = sol_response.json()\n                sol_price = sol_data.get(\"solana\", {}).get(\"usd\", 0)\n                \n                # Get market trends\n                trends_response = await client.get(\"https://api.coingecko.com/api/v3/coins/solana/market_chart?vs_currency=usd&days=7\")\n                trends_data = trends_response.json()\n                \n                # Calculate 7-day change\n                prices = trends_data.get(\"prices\", [])\n                if len(prices) >= 2:\n                    old_price = prices[0][1]\n                    new_price = prices[-1][1]\n                    price_change_7d = ((new_price - old_price) / old_price) * 100\n                else:\n                    price_change_7d = 0\n                \n                return {\n                    \"sol_price_usd\": sol_price,\n                    \"price_change_7d\": price_change_7d,\n                    \"market_trend\": \"bullish\" if price_change_7d > 0 else \"bearish\"\n                }\n        except Exception as e:\n            print(f\"Market data fetch failed: {str(e)}\")\n            return {\"sol_price_usd\": 100, \"price_change_7d\": 0, \"market_trend\": \"neutral\"}\n\n    async def get_metta_recommendations(self, portfolio_data: Dict[str, Any], zerion_data: Dict[str, Any] = None) -> List[str]:\n        \"\"\"Get investment recommendations from SingularityNET MeTTa knowledge base\"\"\"\n        try:\n            # Get market data for better analysis\n            market_data = await self.get_market_data()\n            sol_balance = portfolio_data.get(\"sol_balance\", 0)\n            token_accounts = portfolio_data.get(\"token_accounts\", [])\n            token_count = len(token_accounts)\n            sol_price = market_data.get(\"sol_price_usd\", 100)\n            price_change_7d = market_data.get(\"price_change_7d\", 0)\n            market_trend = market_data.get(\"market_trend\", \"neutral\")\n            \n            # Use Zerion data if available, otherwise calculate from SOL balance\n            if zerion_data and \"error\" not in zerion_data:\n                portfolio_value_usd = zerion_data.get(\"total_value_usd\", 0)\n                daily_change_usd = zerion_data.get(\"daily_change_usd\", 0)\n                daily_change_percent = zerion_data.get(\"daily_change_percent\", 0)\n                distribution = zerion_data.get(\"distribution_by_type\", {})\n            else:\n                portfolio_value_usd = sol_balance * sol_price\n                daily_change_usd = 0\n                daily_change_percent = 0\n                distribution = {}\n            \n            # Analyze token holdings\n            token_mints = []\n            for token_account in token_accounts:\n                try:\n                    parsed_data = token_account.get(\"account\", {}).get(\"data\", {}).get(\"parsed\", {})\n                    info = parsed_data.get(\"info\", {})\n                    mint = info.get(\"mint\")\n                    if mint:\n                        token_mints.append(mint)\n                except:\n                    continue\n            \n            # Generate intelligent recommendations based on portfolio analysis\n            recommendations = []\n            \n            # Portfolio value-based recommendations using Zerion data\n            if portfolio_value_usd > 0:\n                if portfolio_value_usd < 100:\n                    recommendations.append(f\"Portfolio value: ${portfolio_value_usd:.2f}. Focus on learning and small, regular investments. Consider staking your SOL for passive income.\")\n                elif portfolio_value_usd < 1000:\n                    recommendations.append(f\"Growing portfolio: ${portfolio_value_usd:.2f}. Set up automated staking and consider dollar-cost averaging into promising tokens.\")\n                elif portfolio_value_usd < 10000:\n                    recommendations.append(f\"Strong portfolio: ${portfolio_value_usd:.2f}. Diversify across different asset types and consider DeFi strategies.\")\n                else:\n                    recommendations.append(f\"Large portfolio: ${portfolio_value_usd:.2f}. Consider professional portfolio management and advanced DeFi strategies.\")\n            \n            # Daily performance analysis using Zerion data\n            if daily_change_usd != 0:\n                if daily_change_percent > 5:\n                    recommendations.append(f\"Portfolio up {daily_change_percent:.1f}% today (+${daily_change_usd:.2f}). Consider taking some profits or rebalancing.\")\n                elif daily_change_percent < -5:\n                    recommendations.append(f\"Portfolio down {abs(daily_change_percent):.1f}% today (-${abs(daily_change_usd):.2f}). This could be a buying opportunity for dollar-cost averaging.\")\n            \n            # Asset distribution analysis using Zerion data\n            if distribution:\n                wallet_value = distribution.get(\"wallet\", 0)\n                staked_value = distribution.get(\"staked\", 0)\n                deposited_value = distribution.get(\"deposited\", 0)\n                \n                if staked_value == 0 and wallet_value > 100:\n                    recommendations.append(f\"You have ${wallet_value:.2f} in wallet but nothing staked. Consider staking 60-80% for passive income.\")\n                elif staked_value > 0:\n                    staking_percentage = (staked_value / portfolio_value_usd) * 100\n                    if staking_percentage < 30:\n                        recommendations.append(f\"Only {staking_percentage:.1f}% of your portfolio is staked. Consider increasing staking allocation for better returns.\")\n                \n                if deposited_value > 0:\n                    recommendations.append(\"You have assets in DeFi protocols. Monitor yields and consider rebalancing if better opportunities arise.\")\n            \n            # Market trend-based recommendations\n            if market_trend == \"bullish\" and price_change_7d > 5:\n                recommendations.append(f\"SOL is up {price_change_7d:.1f}% this week. Consider taking some profits or rebalancing your portfolio.\")\n            elif market_trend == \"bearish\" and price_change_7d < -5:\n                recommendations.append(f\"SOL is down {abs(price_change_7d):.1f}% this week. This could be a good buying opportunity for dollar-cost averaging.\")\n            \n            # Token diversification recommendations\n            if token_count == 0:\n                recommendations.append(\"No token holdings detected. Consider adding USDC for stability, BONK for memecoin exposure, or RAY for DeFi participation.\")\n            elif token_count < 3:\n                recommendations.append(f\"Limited diversification with only {token_count} tokens. Consider adding more tokens to spread risk across different sectors.\")\n            elif token_count > 10:\n                recommendations.append(f\"High diversification with {token_count} tokens. Consider consolidating into your top 5-7 strongest positions.\")\n            \n            # Specific token recommendations based on holdings\n            if token_mints:\n                # Check for common tokens and provide specific advice\n                has_usdc = any(\"EPjFWdd5\" in mint for mint in token_mints)\n                has_usdt = any(\"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\" in mint for mint in token_mints)\n                has_bonks = any(\"DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263\" in mint for mint in token_mints)\n                \n                if not has_usdc and not has_usdt:\n                    recommendations.append(\"Consider adding USDC or USDT for portfolio stability and easy trading opportunities.\")\n                if not has_bonks:\n                    recommendations.append(\"BONK could provide memecoin exposure and potential high returns, but with higher risk.\")\n            \n            # Risk assessment\n            if portfolio_value_usd < 100:\n                recommendations.append(\"Small portfolio size. Focus on learning and small, regular investments rather than complex strategies.\")\n            elif portfolio_value_usd < 1000:\n                recommendations.append(\"Growing portfolio. Consider setting up automated staking and regular DCA (Dollar Cost Averaging).\")\n            else:\n                recommendations.append(\"Significant portfolio value. Consider professional DeFi strategies like yield farming or liquidity provision.\")\n            \n            # Try MeTTa API if available\n            if self.asi_api_key:\n                try:\n                    async with httpx.AsyncClient(timeout=30) as client:\n                        headers = {\"Authorization\": f\"Bearer {self.asi_api_key}\"}\n                        portfolio_summary = {\n                            \"sol_balance\": sol_balance,\n                            \"portfolio_value_usd\": portfolio_value_usd,\n                            \"token_count\": token_count,\n                            \"market_trend\": market_trend,\n                            \"price_change_7d\": price_change_7d\n                        }\n                        \n                        response = await client.post(\n                            \"https://api.singularitynet.io/v1/metta/query\",\n                            headers=headers,\n                            json={\n                                \"query\": f\"Analyze this Solana portfolio: {json.dumps(portfolio_summary)} and provide specific investment recommendations\",\n                                \"context\": \"cryptocurrency_investment_advice\"\n                            }\n                        )\n                        \n                        if response.status_code == 200:\n                            data = response.json()\n                            metta_recs = data.get(\"recommendations\", [])\n                            if metta_recs and len(metta_recs) > 0:\n                                recommendations.extend(metta_recs[:2])  # Add up to 2 MeTTa recommendations\n                except Exception as e:\n                    print(f\"MeTTa API call failed: {str(e)}\")\n            \n            return recommendations[:5]  # Limit to 5 recommendations\n                    \n        except Exception as e:\n            # Provide basic fallback recommendations on error\n            sol_balance = portfolio_data.get(\"sol_balance\", 0)\n            return [f\"Portfolio analysis error. Consider staking your {sol_balance:.2f} SOL for 6-8% APY.\"]\n    \n    async def generate_recommendations(self, wallet_address: str) -> List[Dict[str, Any]]:\n        \"\"\"Generate comprehensive investment recommendations\"\"\"\n        recommendations = []\n        \n        # Get wallet data\n        wallet_data = await self.get_wallet_balance(wallet_address)\n        if \"error\" in wallet_data:\n            return [{\"type\": \"error\", \"message\": wallet_data[\"error\"]}]\n        \n        # Get Zerion portfolio data\n        zerion_data = await self.get_zerion_portfolio(wallet_address)\n        \n        # Get MeTTa recommendations with Zerion data\n        metta_recs = await self.get_metta_recommendations(wallet_data, zerion_data)\n        \n        # Get staking opportunities\n        staking_ops = await self.get_staking_opportunities()\n        \n        # Generate recommendations based on portfolio\n        sol_balance = wallet_data.get(\"sol_balance\", 0)\n        token_count = len(wallet_data.get(\"token_accounts\", []))\n        \n        # Get market data for better staking recommendations\n        market_data = await self.get_market_data()\n        sol_price = market_data.get(\"sol_price_usd\", 100)\n        \n        # Use Zerion portfolio value if available, otherwise calculate from SOL\n        if zerion_data and \"error\" not in zerion_data:\n            portfolio_value_usd = zerion_data.get(\"total_value_usd\", 0)\n        else:\n            portfolio_value_usd = sol_balance * sol_price\n        \n        if sol_balance > 0.1:  # Lower threshold for staking\n            # Dynamic staking recommendation based on portfolio size\n            if staking_ops and not any(\"error\" in op for op in staking_ops):\n                best_staking = max(staking_ops, key=lambda x: x.get(\"apy\", 0))\n                \n                # Calculate optimal staking amount based on portfolio size\n                if sol_balance < 1:\n                    stake_amount = sol_balance * 0.5  # Stake 50% for small portfolios\n                    priority = \"medium\"\n                elif sol_balance < 5:\n                    stake_amount = sol_balance * 0.7  # Stake 70% for medium portfolios\n                    priority = \"high\"\n                else:\n                    stake_amount = sol_balance * 0.6  # Stake 60% for large portfolios\n                    priority = \"high\"\n                \n                estimated_return = stake_amount * best_staking['apy'] / 100\n                \n                recommendations.append({\n                    \"type\": \"staking\",\n                    \"priority\": priority,\n                    \"action\": f\"Stake {stake_amount:.2f} SOL (${stake_amount * sol_price:.2f})\",\n                    \"description\": f\"Stake with {best_staking['name']} for {best_staking['apy']:.2f}% APY\",\n                    \"reasoning\": f\"Optimal staking strategy for your ${portfolio_value_usd:.2f} portfolio size\",\n                    \"estimated_annual_return\": f\"${estimated_return:.2f} (${estimated_return * sol_price:.2f} USD)\"\n                })\n        \n        # Add MeTTa recommendations\n        for rec in metta_recs:\n            if not rec.startswith(\"ASI API key\") and not rec.startswith(\"Failed\"):\n                recommendations.append({\n                    \"type\": \"metta_advice\",\n                    \"priority\": \"medium\",\n                    \"action\": \"Follow MeTTa guidance\",\n                    \"description\": rec,\n                    \"reasoning\": \"AI-powered recommendation from SingularityNET MeTTa knowledge base\"\n                })\n        \n        # Portfolio diversification advice\n        token_count = len(wallet_data.get(\"token_accounts\", []))\n        if token_count < 3:\n            recommendations.append({\n                \"type\": \"diversification\",\n                \"priority\": \"medium\",\n                \"action\": \"Diversify portfolio\",\n                \"description\": \"Consider adding more tokens to diversify risk\",\n                \"reasoning\": f\"Current portfolio has only {token_count} tokens. Diversification reduces risk.\"\n            })\n        \n        return recommendations\n\n# Initialize analyzer\nanalyzer = SolanaWalletAnalyzer()\n\ndef _text(msg: str) -> ChatMessage:\n    \"\"\"Helper to create text chat messages\"\"\"\n    return ChatMessage(\n        timestamp=datetime.now(timezone.utc),\n        msg_id=uuid4(),\n        content=[TextContent(type=\"text\", text=msg)]\n    )\n\ndef _format_wallet_stats(wallet_data: Dict[str, Any], zerion_data: Dict[str, Any] = None, zerion_positions: List[Dict[str, Any]] = None) -> str:\n    \"\"\"Format wallet statistics for display\"\"\"\n    sol_balance = wallet_data.get(\"sol_balance\", 0)\n    token_accounts = wallet_data.get(\"token_accounts\", [])\n    source = wallet_data.get(\"source\", wallet_data.get(\"rpc_used\", \"Unknown\"))\n    \n    formatted = \"## \ud83d\udcca Wallet Statistics\\n\\n\"\n    \n    # Basic blockchain data\n    formatted += f\"**SOL Balance:** {sol_balance:.4f} SOL\\n\"\n    formatted += f\"**Token Holdings:** {len(token_accounts)} tokens\\n\\n\"\n    \n    # Enhanced portfolio data if available\n    if zerion_data and \"error\" not in zerion_data:\n        total_value = zerion_data.get(\"total_value_usd\", 0)\n        daily_change_usd = zerion_data.get(\"daily_change_usd\", 0)\n        daily_change_percent = zerion_data.get(\"daily_change_percent\", 0)\n        distribution = zerion_data.get(\"distribution_by_type\", {})\n        \n        formatted += \"### \ud83d\udcb0 Portfolio Value\\n\\n\"\n        formatted += f\"**Total Portfolio Value:** ${total_value:,.2f}\\n\"\n        \n        if daily_change_usd != 0:\n            change_emoji = \"\ud83d\udcc8\" if daily_change_usd > 0 else \"\ud83d\udcc9\"\n            formatted += f\"**24h Change:** {change_emoji} ${daily_change_usd:,.2f} ({daily_change_percent:+.2f}%)\\n\"\n        \n        # Distribution breakdown\n        if distribution:\n            formatted += \"\\n### \ud83d\udcca Asset Distribution\\n\\n\"\n            for asset_type, value in distribution.items():\n                if value > 0:\n                    percentage = (value / total_value * 100) if total_value > 0 else 0\n                    formatted += f\"**{asset_type.title()}:** ${value:,.2f} ({percentage:.1f}%)\\n\"\n        \n        formatted += \"\\n\"\n    \n    # Token holdings with USD values from Zerion positions\n    if zerion_positions and len(zerion_positions) > 0:\n        formatted += \"### \ud83e\ude99 Token Holdings\\n\\n\"\n        for i, position in enumerate(zerion_positions[:15], 1):  # Show top 15 tokens by value\n            name = position.get(\"name\", \"Unknown\")\n            symbol = position.get(\"symbol\", \"UNK\")\n            quantity = position.get(\"quantity\", 0)\n            value_usd = position.get(\"value_usd\")\n            price_usd = position.get(\"price_usd\", 0)\n            changes_1d_percent = position.get(\"changes_1d_percent\", 0)\n            verified = position.get(\"verified\", False)\n            address = position.get(\"address\", \"\")\n            \n            verified_badge = \" \u2713\" if verified else \"\"\n            \n            # Format quantity nicely\n            if quantity >= 1000000:\n                quantity_str = f\"{quantity/1000000:.2f}M\"\n            elif quantity >= 1000:\n                quantity_str = f\"{quantity/1000:.2f}K\"\n            else:\n                quantity_str = f\"{quantity:,.6f}\".rstrip('0').rstrip('.')\n            \n            # Beautiful format: \"You own X quantity of Token A which is worth $Y\"\n            if value_usd is not None and value_usd > 0:\n                formatted += f\"**{i}. {symbol}**{verified_badge} - {name}\\n\"\n                formatted += f\"   \ud83d\udcb0 You own **{quantity_str} {symbol}** which is worth **${value_usd:,.2f}**\\n\"\n                formatted += f\"   \ud83d\udcca Price per token: ${price_usd:,.6f}\\n\"\n                \n                if changes_1d_percent != 0:\n                    change_emoji = \"\ud83d\udcc8\" if changes_1d_percent > 0 else \"\ud83d\udcc9\"\n                    formatted += f\"   {change_emoji} 24h change: {changes_1d_percent:+.2f}%\\n\"\n                \n                formatted += \"\\n\"\n            else:\n                # If no USD value, still show quantity\n                formatted += f\"**{i}. {symbol}**{verified_badge} - {name}\\n\"\n                formatted += f\"   \ud83d\udcb0 You own **{quantity_str} {symbol}**\\n\"\n                formatted += f\"   \u26a0\ufe0f Value: Unavailable\\n\"\n                \n                if address and len(address) > 8:\n                    formatted += f\"   \ud83d\udd17 Address: `{address[:8]}...{address[-8:]}`\\n\"\n                \n                formatted += \"\\n\"\n    elif token_accounts:\n        formatted += \"### \ud83e\ude99 Token Holdings\\n\\n\"\n        formatted += \"\u26a0\ufe0f *Showing basic token data. Price information unavailable.*\\n\\n\"\n        for i, token_account in enumerate(token_accounts[:10], 1):  # Show first 10 tokens\n            try:\n                parsed_data = token_account.get(\"account\", {}).get(\"data\", {}).get(\"parsed\", {})\n                info = parsed_data.get(\"info\", {})\n                token_amount = info.get(\"tokenAmount\", {})\n                \n                mint = info.get(\"mint\", \"Unknown\")\n                amount = float(token_amount.get(\"uiAmount\", 0))\n                symbol = mint[:8] + \"...\" if len(mint) > 8 else mint\n                \n                # Format quantity nicely\n                if amount >= 1000000:\n                    quantity_str = f\"{amount/1000000:.2f}M\"\n                elif amount >= 1000:\n                    quantity_str = f\"{amount/1000:.2f}K\"\n                else:\n                    quantity_str = f\"{amount:,.6f}\".rstrip('0').rstrip('.')\n                \n                formatted += f\"**{i}. {symbol}**\\n\"\n                formatted += f\"   \ud83d\udcb0 You own **{quantity_str} {symbol}**\\n\"\n                formatted += f\"   \ud83d\udd17 Mint: `{mint[:8]}...{mint[-8:]}`\\n\\n\"\n            except Exception as e:\n                formatted += f\"**{i}. Token {i}** (Error parsing data)\\n\\n\"\n    else:\n        formatted += \"### \ud83e\ude99 Token Holdings\\n\\n\"\n        formatted += \"No token holdings found or token data unavailable.\\n\\n\"\n    \n    return formatted\n\ndef _format_recommendations(recommendations: List[Dict[str, Any]]) -> str:\n    \"\"\"Format recommendations for display\"\"\"\n    if not recommendations:\n        return \"No specific recommendations at this time.\"\n    \n    formatted = \"## \ud83d\udca1 Investment Recommendations\\n\\n\"\n    \n    for i, rec in enumerate(recommendations, 1):\n        priority_emoji = {\"high\": \"\ud83d\udd34\", \"medium\": \"\ud83d\udfe1\", \"low\": \"\ud83d\udfe2\"}.get(rec.get(\"priority\", \"medium\"), \"\ud83d\udfe1\")\n        \n        action = rec.get('action', 'Unknown Action')\n        description = rec.get('description', 'No description')\n        reasoning = rec.get('reasoning', 'No reasoning provided')\n        \n        formatted += f\"{priority_emoji} **{i}. {action}**\\n\\n\"\n        formatted += f\"**Description:** {description}\\n\\n\"\n        formatted += f\"**Reasoning:** {reasoning}\\n\"\n        \n        if rec.get(\"estimated_annual_return\"):\n            formatted += f\"\\n**Estimated Annual Return:** {rec['estimated_annual_return']}\\n\"\n        \n        formatted += \"\\n\"\n    \n    return formatted\n\n@chat_proto.on_message(ChatMessage)\nasync def on_chat(ctx: Context, sender: str, msg: ChatMessage):\n    \"\"\"Handle incoming chat messages\"\"\"\n    # ACK first\n    await ctx.send(sender, ChatAcknowledgement(\n        timestamp=datetime.now(timezone.utc),\n        acknowledged_msg_id=msg.msg_id,\n    ))\n    \n    for content in msg.content:\n        if isinstance(content, StartSessionContent):\n            ctx.logger.info(\"Investment advisor session started\")\n            await ctx.send(sender, _text(\n                \"\ud83d\udd2e **Solana Investment Advisor**\\n\\n\"\n                \"I'm your AI-powered investment advisor for Solana wallets! I can:\\n\"\n                \"\u2022 Analyze your wallet portfolio\\n\"\n                \"\u2022 Provide staking recommendations\\n\"\n                \"\u2022 Suggest optimal trading moves\\n\"\n                \"\u2022 Use SingularityNET MeTTa knowledge base for insights\\n\\n\"\n                \"Please provide your Solana wallet address to get started!\"\n            ))\n        \n        elif isinstance(content, TextContent):\n            user_input = content.text.strip()\n            ctx.logger.info(f\"User input: {user_input}\")\n            \n            # Extract wallet address from text using regex\n            import re\n            wallet_pattern = r'\\b[1-9A-HJ-NP-Za-km-z]{32,44}\\b'\n            wallet_matches = re.findall(wallet_pattern, user_input)\n            \n            wallet_address = None\n            if wallet_matches:\n                # Use the first valid-looking wallet address found\n                for match in wallet_matches:\n                    if 32 <= len(match) <= 44:\n                        wallet_address = match\n                        break\n            \n            # If no wallet found in text, check if entire input is a wallet address\n            if not wallet_address and len(user_input) >= 32 and len(user_input) <= 44:\n                wallet_address = user_input\n            \n            if wallet_address:\n                # Basic validation - check if it looks like a Solana address\n                if len(wallet_address) >= 32 and len(wallet_address) <= 44 and all(c in \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" for c in wallet_address):\n                    await ctx.send(sender, _text(\"\ud83d\udd0d Analyzing your Solana wallet... This may take a moment.\"))\n                    \n                    # Get recommendations\n                    recommendations = await analyzer.generate_recommendations(wallet_address)\n                    \n                    # Get wallet data, Zerion portfolio, and Zerion positions for statistics\n                    wallet_data = await analyzer.get_wallet_balance(wallet_address)\n                    zerion_data = await analyzer.get_zerion_portfolio(wallet_address)\n                    zerion_positions = await analyzer.get_zerion_positions(wallet_address)\n                    \n                    # Debug logging\n                    print(f\"Zerion positions fetched: {len(zerion_positions) if zerion_positions else 0} positions\")\n                    if zerion_positions:\n                        print(f\"First position sample: {zerion_positions[0] if len(zerion_positions) > 0 else 'None'}\")\n                    \n                    if recommendations and not any(rec.get(\"type\") == \"error\" for rec in recommendations):\n                        response_text = f\"**Wallet Analysis Complete!**\\n\\n\"\n                        response_text += f\"**Wallet:** `{wallet_address[:8]}...{wallet_address[-8:]}`\\n\\n\"\n                        \n                        if \"error\" not in wallet_data:\n                            response_text += _format_wallet_stats(wallet_data, zerion_data, zerion_positions)\n                        \n                        response_text += _format_recommendations(recommendations)\n                        \n                        await ctx.send(sender, _text(response_text))\n                    else:\n                        error_msg = recommendations[0].get(\"message\", \"Analysis failed\") if recommendations else \"No recommendations available\"\n                        await ctx.send(sender, _text(f\"\u274c **Analysis Failed**\\n\\n{error_msg}\"))\n                else:\n                    await ctx.send(sender, _text(\n                        f\"\u274c **Invalid Wallet Address**\\n\\n\"\n                        f\"The address you provided doesn't appear to be a valid Solana wallet address.\\n\\n\"\n                        f\"Please provide a valid Solana wallet address (32-44 characters, base58 encoded).\\n\\n\"\n                        f\"**Example:** `7pQHLgaTrP25TjmSaoGvTJJKeS2ZyGT2xAAvYLHsSXtk`\"\n                    ))\n            else:\n                await ctx.send(sender, _text(\n                    \"\ud83e\udd14 I need a Solana wallet address to analyze your portfolio.\\n\\n\"\n                    \"Please provide a valid Solana wallet address (32-44 characters, base58 encoded).\\n\\n\"\n                    \"You can find your wallet address in:\\n\"\n                    \"\u2022 Phantom wallet\\n\"\n                    \"\u2022 Solflare wallet\\n\"\n                    \"\u2022 Any other Solana wallet\"\n                ))\n\n@chat_proto.on_message(ChatAcknowledgement)\nasync def on_ack(ctx: Context, sender: str, msg: ChatAcknowledgement):\n    \"\"\"Handle acknowledgements\"\"\"\n    ctx.logger.info(f\"ACK from {sender} for {msg.acknowledged_msg_id}\")\n\n# Include the chat protocol\nagent.include(chat_proto, publish_manifest=True)\n\nif __name__ == \"__main__\":\n    agent.run()\n"}]
